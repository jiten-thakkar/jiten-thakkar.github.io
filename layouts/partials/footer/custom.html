<!-- Ocean Theme as Default (but allow dark mode toggle) -->
<script>
(function() {
    // Function to apply the correct theme
    function applyCorrectTheme() {
        const savedScheme = localStorage.getItem('StackColorScheme');

        if (savedScheme === 'dark') {
            document.documentElement.setAttribute('data-scheme', 'dark');
        } else {
            // For 'light', 'auto', or no preference - use Ocean
            document.documentElement.setAttribute('data-scheme', 'ocean');
        }
    }

    // Apply theme immediately
    applyCorrectTheme();

    // Watch for changes to data-scheme attribute (when user clicks toggle)
    const observer = new MutationObserver(function(mutations) {
        mutations.forEach(function(mutation) {
            if (mutation.type === 'attributes' && mutation.attributeName === 'data-scheme') {
                const currentScheme = document.documentElement.getAttribute('data-scheme');
                const savedScheme = localStorage.getItem('StackColorScheme');

                // If Stack theme set it to 'light', change it to 'ocean'
                if (currentScheme === 'light' && savedScheme === 'light') {
                    document.documentElement.setAttribute('data-scheme', 'ocean');
                }
            }
        });
    });

    // Start observing
    observer.observe(document.documentElement, {
        attributes: true,
        attributeFilter: ['data-scheme']
    });

    // Also apply on page load
    window.addEventListener('DOMContentLoaded', applyCorrectTheme);
    window.addEventListener('load', applyCorrectTheme);
})();
</script>

<!-- Remove ** markers from captions -->
<script>
(function() {
    function cleanCaptions() {
        // Find all figcaption elements and their children
        const captions = document.querySelectorAll('figcaption, figcaption *');

        captions.forEach(function(element) {
            // Get all text nodes and clean them
            const walker = document.createTreeWalker(
                element,
                NodeFilter.SHOW_TEXT,
                null,
                false
            );

            const textNodes = [];
            let node;
            while (node = walker.nextNode()) {
                textNodes.push(node);
            }

            textNodes.forEach(function(textNode) {
                textNode.textContent = textNode.textContent.replace(/\*\*/g, '');
            });

            // Also clean innerHTML as fallback
            if (element.innerHTML) {
                element.innerHTML = element.innerHTML.replace(/\*\*/g, '');
            }
        });

        console.log('Cleaned captions - found', document.querySelectorAll('figcaption').length, 'figcaption elements');
    }

    // Run immediately
    cleanCaptions();

    // Run when DOM is loaded
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', cleanCaptions);
    }

    // Also run after delays to catch dynamically loaded content
    setTimeout(cleanCaptions, 50);
    setTimeout(cleanCaptions, 100);
    setTimeout(cleanCaptions, 500);
    setTimeout(cleanCaptions, 1000);

    // Run on window load as final attempt
    window.addEventListener('load', cleanCaptions);
})();
</script>
